var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/index.tsx
import { useEffect as useEffect3, useMemo as useMemo3 } from "react";
import { useSingleton as useSingleton3 } from "@gilbarbara/hooks";

// src/modules/dom.ts
import scroll from "scroll";
import scrollParent from "scrollparent";
function canUseDOM() {
  var _a;
  return !!(typeof window !== "undefined" && ((_a = window.document) == null ? void 0 : _a.createElement));
}
function getClientRect(element) {
  if (!element) {
    return null;
  }
  return element.getBoundingClientRect();
}
function getDocumentHeight(median = false) {
  const { body, documentElement } = document;
  if (!body || !documentElement) {
    return 0;
  }
  if (median) {
    const heights = [
      body.scrollHeight,
      body.offsetHeight,
      documentElement.clientHeight,
      documentElement.scrollHeight,
      documentElement.offsetHeight
    ].sort((a, b) => a - b);
    const middle = Math.floor(heights.length / 2);
    if (heights.length % 2 === 0) {
      return (heights[middle - 1] + heights[middle]) / 2;
    }
    return heights[middle];
  }
  return Math.max(
    body.scrollHeight,
    body.offsetHeight,
    documentElement.clientHeight,
    documentElement.scrollHeight,
    documentElement.offsetHeight
  );
}
function getElement(element) {
  if (!element) {
    return null;
  }
  if (typeof element === "string") {
    try {
      return document.querySelector(element);
    } catch (error) {
      if (process.env.NODE_ENV !== "production") {
        console.error(error);
      }
      return null;
    }
  }
  return element;
}
function getStyleComputedProperty(el) {
  if (!el || el.nodeType !== 1) {
    return null;
  }
  return getComputedStyle(el);
}
function getScrollParent(element, skipFix, forListener) {
  if (!element) {
    return scrollDocument();
  }
  const parent = scrollParent(element);
  if (parent) {
    if (parent.isSameNode(scrollDocument())) {
      if (forListener) {
        return document;
      }
      return scrollDocument();
    }
    const hasScrolling = parent.scrollHeight > parent.offsetHeight;
    if (!hasScrolling && !skipFix) {
      parent.style.overflow = "initial";
      return scrollDocument();
    }
  }
  return parent;
}
function hasCustomScrollParent(element, skipFix) {
  if (!element) {
    return false;
  }
  const parent = getScrollParent(element, skipFix);
  return parent ? !parent.isSameNode(scrollDocument()) : false;
}
function hasCustomOffsetParent(element) {
  return element.offsetParent !== document.body;
}
function hasPosition(el, type = "fixed") {
  if (!el || !(el instanceof HTMLElement)) {
    return false;
  }
  const { nodeName } = el;
  const styles = getStyleComputedProperty(el);
  if (nodeName === "BODY" || nodeName === "HTML") {
    return false;
  }
  if (styles && styles.position === type) {
    return true;
  }
  if (!el.parentNode) {
    return false;
  }
  return hasPosition(el.parentNode, type);
}
function isElementVisible(element) {
  var _a;
  if (!element) {
    return false;
  }
  let parentElement = element;
  while (parentElement) {
    if (parentElement === document.body) {
      break;
    }
    if (parentElement instanceof HTMLElement) {
      const { display, visibility } = getComputedStyle(parentElement);
      if (display === "none" || visibility === "hidden") {
        return false;
      }
    }
    parentElement = (_a = parentElement.parentElement) != null ? _a : null;
  }
  return true;
}
function getElementPosition(element, offset, skipFix) {
  var _a, _b, _c;
  const elementRect = getClientRect(element);
  const parent = getScrollParent(element, skipFix);
  const hasScrollParent = hasCustomScrollParent(element, skipFix);
  const isFixedTarget = hasPosition(element);
  let parentTop = 0;
  let top = (_a = elementRect == null ? void 0 : elementRect.top) != null ? _a : 0;
  if (hasScrollParent && isFixedTarget) {
    const offsetTop = (_b = element == null ? void 0 : element.offsetTop) != null ? _b : 0;
    const parentScrollTop = (_c = parent == null ? void 0 : parent.scrollTop) != null ? _c : 0;
    top = offsetTop - parentScrollTop;
  } else if (parent instanceof HTMLElement) {
    parentTop = parent.scrollTop;
    if (!hasScrollParent && !hasPosition(element)) {
      top += parentTop;
    }
    if (!parent.isSameNode(scrollDocument())) {
      top += scrollDocument().scrollTop;
    }
  }
  return Math.floor(top - offset);
}
function getScrollTo(element, offset, skipFix) {
  var _a;
  if (!element) {
    return 0;
  }
  const { offsetTop = 0, scrollTop = 0 } = (_a = scrollParent(element)) != null ? _a : {};
  let top = element.getBoundingClientRect().top + scrollTop;
  if (!!offsetTop && (hasCustomScrollParent(element, skipFix) || hasCustomOffsetParent(element))) {
    top -= offsetTop;
  }
  const output = Math.floor(top - offset);
  return output < 0 ? 0 : output;
}
function scrollDocument() {
  var _a;
  return (_a = document.scrollingElement) != null ? _a : document.documentElement;
}
function scrollTo(value, options) {
  const { duration, element } = options;
  return new Promise((resolve, reject) => {
    const { scrollTop } = element;
    const limit = value > scrollTop ? value - scrollTop : scrollTop - value;
    scroll.top(element, value, { duration: limit < 100 ? 50 : duration }, (error) => {
      if (error && error.message !== "Element already at target scroll position") {
        return reject(error);
      }
      return resolve();
    });
  });
}

// src/modules/helpers.tsx
import { cloneElement, isValidElement } from "react";
import innerText from "react-innertext";
import is from "is-lite";

// src/literals/index.ts
var ACTIONS = {
  INIT: "init",
  START: "start",
  STOP: "stop",
  RESET: "reset",
  PREV: "prev",
  NEXT: "next",
  GO: "go",
  CLOSE: "close",
  SKIP: "skip",
  UPDATE: "update",
  COMPLETE: "complete"
};
var EVENTS = {
  TOUR_START: "tour:start",
  STEP_BEFORE: "step:before",
  BEACON: "beacon",
  TOOLTIP: "tooltip",
  STEP_AFTER: "step:after",
  TOUR_END: "tour:end",
  TOUR_STATUS: "tour:status",
  TARGET_NOT_FOUND: "error:target_not_found",
  ERROR: "error"
};
var LIFECYCLE = {
  INIT: "init",
  READY: "ready",
  BEACON: "beacon",
  TOOLTIP: "tooltip",
  COMPLETE: "complete",
  ERROR: "error"
};
var ORIGIN = {
  BUTTON_CLOSE: "button_close",
  BUTTON_PRIMARY: "button_primary",
  KEYBOARD: "keyboard",
  OVERLAY: "overlay"
};
var STATUS = {
  IDLE: "idle",
  READY: "ready",
  WAITING: "waiting",
  RUNNING: "running",
  PAUSED: "paused",
  SKIPPED: "skipped",
  FINISHED: "finished",
  ERROR: "error"
};
var PORTAL_ELEMENT_ID = "react-joyride-portal";

// src/modules/helpers.tsx
function cleanUpObject(input) {
  const output = {};
  for (const key in input) {
    if (input[key] !== void 0) {
      output[key] = input[key];
    }
  }
  return output;
}
function getBrowser(userAgent = navigator.userAgent) {
  let browser = userAgent;
  if (typeof window === "undefined") {
    browser = "node";
  } else if (document.documentMode) {
    browser = "ie";
  } else if (/Edge/.test(userAgent)) {
    browser = "edge";
  } else if (Boolean(window.opera) || userAgent.includes(" OPR/")) {
    browser = "opera";
  } else if (typeof window.InstallTrigger !== "undefined") {
    browser = "firefox";
  } else if (window.chrome) {
    browser = "chrome";
  } else if (/(Version\/([\d._]+).*Safari|CriOS|FxiOS| Mobile\/)/.test(userAgent)) {
    browser = "safari";
  }
  return browser;
}
function getObjectType(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}
function getReactNodeText(input, options = {}) {
  const { defaultValue, step, steps } = options;
  let text = innerText(input);
  if (!text) {
    if (isValidElement(input) && !Object.values(input.props).length && getObjectType(input.type) === "function") {
      const component = input.type({});
      text = getReactNodeText(component, options);
    } else {
      text = innerText(defaultValue);
    }
  } else if ((text.includes("{step}") || text.includes("{steps}")) && step && steps) {
    text = text.replace("{step}", step.toString()).replace("{steps}", steps.toString());
  }
  return text;
}
function hexToRGB(hex) {
  const shorthandRegex = /^#?([\da-f])([\da-f])([\da-f])$/i;
  const properHex = hex.replace(shorthandRegex, (_m, r, g, b) => r + r + g + g + b + b);
  const result = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(properHex);
  return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [];
}
function hideBeacon(step, state, continuous) {
  const { action } = state;
  const withContinuous = continuous && [ACTIONS.PREV, ACTIONS.NEXT].includes(action);
  return step.disableBeacon || step.placement === "center" || withContinuous;
}
function isLegacy() {
  return !["chrome", "safari", "firefox", "opera"].includes(getBrowser());
}
function log({ data, debug = false, title, warn = false }) {
  var _a;
  const logFn = warn ? (_a = console.warn) != null ? _a : console.error : console.log;
  if (debug) {
    if (title && data) {
      console.groupCollapsed(
        `%creact-joyride: ${title}`,
        "color: #ff0044; font-weight: bold; font-size: 12px;"
      );
      if (Array.isArray(data)) {
        data.forEach((d) => {
          if (is.plainObject(d) && d.key) {
            logFn.apply(console, [d.key, d.value]);
          } else {
            logFn.apply(console, [d]);
          }
        });
      } else {
        logFn.apply(console, [data]);
      }
      console.groupEnd();
    } else {
      console.error("Missing title or data props");
    }
  }
}
function mergeProps(defaultProps2, props) {
  const cleanProps = cleanUpObject(props);
  return { ...defaultProps2, ...cleanProps };
}
function noop() {
  return void 0;
}
function omit(input, ...filter) {
  if (!is.plainObject(input)) {
    throw new TypeError("Expected an object");
  }
  const output = {};
  for (const key in input) {
    if ({}.hasOwnProperty.call(input, key)) {
      if (!filter.includes(key)) {
        output[key] = input[key];
      }
    }
  }
  return output;
}
function pick(input, ...filter) {
  if (!is.plainObject(input)) {
    throw new TypeError("Expected an object");
  }
  if (!filter.length) {
    return input;
  }
  const output = {};
  for (const key in input) {
    if ({}.hasOwnProperty.call(input, key)) {
      if (filter.includes(key)) {
        output[key] = input[key];
      }
    }
  }
  return output;
}
function replaceLocaleContent(input, step, steps) {
  const replacer = (text) => text.replace("{step}", String(step)).replace("{steps}", String(steps));
  if (getObjectType(input) === "string") {
    return replacer(input);
  }
  if (!isValidElement(input)) {
    return input;
  }
  const { children } = input.props;
  if (getObjectType(children) === "string" && children.includes("{step}")) {
    return cloneElement(input, {
      children: replacer(children)
    });
  }
  if (Array.isArray(children)) {
    return cloneElement(input, {
      children: children.map((child) => {
        if (typeof child === "string") {
          return replacer(child);
        }
        return replaceLocaleContent(child, step, steps);
      })
    });
  }
  if (getObjectType(input.type) === "function" && !Object.values(input.props).length) {
    const component = input.type({});
    return replaceLocaleContent(component, step, steps);
  }
  return input;
}
function shouldScroll(options) {
  const { isFirstStep, lifecycle, previousLifecycle, scrollToFirstStep, step, target } = options;
  return !step.disableScrolling && (!isFirstStep || scrollToFirstStep || lifecycle === LIFECYCLE.TOOLTIP) && step.placement !== "center" && (!step.isFixed || !hasPosition(target)) && // fixed steps don't need to scroll
  previousLifecycle !== lifecycle && [LIFECYCLE.BEACON, LIFECYCLE.TOOLTIP].includes(lifecycle);
}

// src/modules/step.ts
import deepmerge2 from "deepmerge";
import is2 from "is-lite";

// src/defaults.ts
var defaultFloaterProps = {
  modifiers: {
    preventOverflow: {
      options: {
        rootBoundary: "viewport"
      }
    }
  },
  wrapperOptions: {
    offset: -18,
    position: true
  }
};
var defaultLocale = {
  back: "Back",
  close: "Close",
  last: "Last",
  next: "Next",
  nextLabelWithProgress: "Next (Step {step} of {steps})",
  open: "Open the dialog",
  skip: "Skip"
};
var defaultStep = {
  event: "click",
  placement: "bottom",
  offset: 10,
  disableBeacon: false,
  disableCloseOnEsc: false,
  disableOverlay: false,
  disableOverlayClose: false,
  disableScrollParentFix: false,
  disableScrolling: false,
  hideBackButton: false,
  hideCloseButton: false,
  hideFooter: false,
  isFixed: false,
  locale: defaultLocale,
  showProgress: false,
  showSkipButton: false,
  spotlightClicks: false,
  spotlightPadding: 10
};
var defaultProps = {
  continuous: false,
  debug: false,
  disableCloseOnEsc: false,
  disableOverlay: false,
  disableOverlayClose: false,
  disableScrolling: false,
  disableScrollParentFix: false,
  getHelpers: noop(),
  hideBackButton: false,
  run: true,
  scrollOffset: 20,
  scrollDuration: 300,
  scrollToFirstStep: false,
  showSkipButton: false,
  showProgress: false,
  spotlightClicks: false,
  spotlightPadding: 10,
  steps: []
};
var defaultState = {
  action: ACTIONS.INIT,
  controlled: false,
  index: 0,
  lifecycle: LIFECYCLE.INIT,
  origin: null,
  size: 0,
  status: STATUS.IDLE
};

// src/styles.ts
import deepmerge from "deepmerge";
var defaultOptions = {
  arrowColor: "#fff",
  backgroundColor: "#fff",
  beaconSize: 36,
  overlayColor: "rgba(0, 0, 0, 0.5)",
  primaryColor: "#f04",
  spotlightShadow: "0 0 15px rgba(0, 0, 0, 0.5)",
  textColor: "#333",
  width: 380,
  zIndex: 100
};
var buttonBase = {
  backgroundColor: "transparent",
  border: 0,
  borderRadius: 0,
  color: "#555",
  cursor: "pointer",
  fontSize: 16,
  lineHeight: 1,
  padding: 8,
  WebkitAppearance: "none"
};
var spotlight = {
  borderRadius: 4,
  position: "absolute"
};
function getStyles(props, step) {
  var _a, _b, _c, _d, _e;
  const { floaterProps, styles } = props;
  const mergedFloaterProps = deepmerge((_a = step.floaterProps) != null ? _a : {}, floaterProps != null ? floaterProps : {});
  const mergedStyles = deepmerge(styles != null ? styles : {}, (_b = step.styles) != null ? _b : {});
  const options = deepmerge(defaultOptions, mergedStyles.options || {});
  const hideBeacon2 = step.placement === "center" || step.disableBeacon;
  let { width } = options;
  if (window.innerWidth > 480) {
    width = 380;
  }
  if ("width" in options) {
    width = typeof options.width === "number" && window.innerWidth < options.width ? window.innerWidth - 30 : options.width;
  }
  const overlay = {
    bottom: 0,
    left: 0,
    overflow: "hidden",
    position: "absolute",
    right: 0,
    top: 0,
    zIndex: options.zIndex
  };
  const defaultStyles = {
    beacon: {
      ...buttonBase,
      display: hideBeacon2 ? "none" : "inline-block",
      height: options.beaconSize,
      position: "relative",
      width: options.beaconSize,
      zIndex: options.zIndex
    },
    beaconInner: {
      animation: "joyride-beacon-inner 1.2s infinite ease-in-out",
      backgroundColor: options.primaryColor,
      borderRadius: "50%",
      display: "block",
      height: "50%",
      left: "50%",
      opacity: 0.7,
      position: "absolute",
      top: "50%",
      transform: "translate(-50%, -50%)",
      width: "50%"
    },
    beaconOuter: {
      animation: "joyride-beacon-outer 1.2s infinite ease-in-out",
      backgroundColor: `rgba(${hexToRGB(options.primaryColor).join(",")}, 0.2)`,
      border: `2px solid ${options.primaryColor}`,
      borderRadius: "50%",
      boxSizing: "border-box",
      display: "block",
      height: "100%",
      left: 0,
      opacity: 0.9,
      position: "absolute",
      top: 0,
      transformOrigin: "center",
      width: "100%"
    },
    tooltip: {
      backgroundColor: options.backgroundColor,
      borderRadius: 5,
      boxSizing: "border-box",
      color: options.textColor,
      fontSize: 16,
      maxWidth: "100%",
      padding: 15,
      position: "relative",
      width
    },
    tooltipContainer: {
      lineHeight: 1.4,
      textAlign: "center"
    },
    tooltipTitle: {
      fontSize: 18,
      margin: 0
    },
    tooltipContent: {
      padding: "20px 10px"
    },
    tooltipFooter: {
      alignItems: "center",
      display: "flex",
      justifyContent: "flex-end",
      marginTop: 15
    },
    tooltipFooterSpacer: {
      flex: 1
    },
    buttonNext: {
      ...buttonBase,
      backgroundColor: options.primaryColor,
      borderRadius: 4,
      color: "#fff"
    },
    buttonBack: {
      ...buttonBase,
      color: options.primaryColor,
      marginLeft: "auto",
      marginRight: 5
    },
    buttonClose: {
      ...buttonBase,
      color: options.textColor,
      height: 14,
      padding: 15,
      position: "absolute",
      right: 0,
      top: 0,
      width: 14
    },
    buttonSkip: {
      ...buttonBase,
      color: options.textColor,
      fontSize: 14
    },
    overlay: {
      ...overlay,
      backgroundColor: options.overlayColor,
      mixBlendMode: "hard-light"
    },
    overlayLegacy: {
      ...overlay
    },
    overlayLegacyCenter: {
      ...overlay,
      backgroundColor: options.overlayColor
    },
    spotlight: {
      ...spotlight,
      backgroundColor: "gray"
    },
    spotlightLegacy: {
      ...spotlight,
      boxShadow: `0 0 0 9999px ${options.overlayColor}, ${options.spotlightShadow}`
    },
    floaterStyles: {
      arrow: {
        color: (_e = (_d = (_c = mergedFloaterProps == null ? void 0 : mergedFloaterProps.styles) == null ? void 0 : _c.arrow) == null ? void 0 : _d.color) != null ? _e : options.arrowColor
      },
      options: {
        zIndex: options.zIndex + 100
      }
    },
    options
  };
  return deepmerge(defaultStyles, mergedStyles);
}

// src/modules/step.ts
function getTourProps(props) {
  return pick(
    props,
    "beaconComponent",
    "disableCloseOnEsc",
    "disableOverlay",
    "disableOverlayClose",
    "disableScrolling",
    "disableScrollParentFix",
    "floaterProps",
    "hideBackButton",
    "hideCloseButton",
    "locale",
    "showProgress",
    "showSkipButton",
    "spotlightClicks",
    "spotlightPadding",
    "styles",
    "tooltipComponent"
  );
}
function getMergedStep(props, currentStep) {
  var _a, _b, _c, _d, _e, _f;
  if (!currentStep) {
    return null;
  }
  const step = currentStep != null ? currentStep : {};
  const mergedStep = deepmerge2.all([defaultStep, getTourProps(props), step], {
    isMergeableObject: is2.plainObject
  });
  const mergedStyles = getStyles(props, mergedStep);
  const scrollParent2 = hasCustomScrollParent(
    getElement(mergedStep.target),
    mergedStep.disableScrollParentFix
  );
  const floaterProps = deepmerge2.all([
    defaultFloaterProps,
    (_a = props.floaterProps) != null ? _a : {},
    (_b = mergedStep.floaterProps) != null ? _b : {}
  ]);
  floaterProps.offset = mergedStep.offset;
  floaterProps.styles = deepmerge2((_c = floaterProps.styles) != null ? _c : {}, mergedStyles.floaterStyles);
  floaterProps.offset += (_e = (_d = props.spotlightPadding) != null ? _d : mergedStep.spotlightPadding) != null ? _e : 0;
  if (mergedStep.placementBeacon && floaterProps.wrapperOptions) {
    floaterProps.wrapperOptions.placement = mergedStep.placementBeacon;
  }
  if (scrollParent2 && floaterProps.modifiers.preventOverflow) {
    floaterProps.modifiers.preventOverflow.options = {
      ...floaterProps.modifiers.preventOverflow.options,
      rootBoundary: "viewport",
      boundary: "clippingParents"
    };
  }
  return {
    ...mergedStep,
    locale: deepmerge2.all([defaultLocale, (_f = props.locale) != null ? _f : {}, mergedStep.locale || {}]),
    floaterProps,
    styles: omit(mergedStyles, "floaterStyles")
  };
}
function validateStep(step, debug = false) {
  if (!is2.plainObject(step)) {
    log({
      title: "validateStep",
      data: "step must be an object",
      warn: true,
      debug
    });
    return false;
  }
  if (!step.target) {
    log({
      title: "validateStep",
      data: "target is missing from the step",
      warn: true,
      debug
    });
    return false;
  }
  return true;
}
function validateSteps(steps, debug = false) {
  if (!is2.array(steps)) {
    log({
      title: "validateSteps",
      data: "steps must be an array",
      warn: true,
      debug
    });
    return false;
  }
  return steps.every((d) => validateStep(d, debug));
}

// src/modules/useJoyrideData.ts
import { useCallback, useMemo, useRef } from "react";
import isEqual from "@gilbarbara/deep-equal";
import {
  useDeepCompareEffect,
  useMount,
  usePrevious,
  useSetState,
  useSingleton,
  useUpdateEffect
} from "@gilbarbara/hooks";
import is4 from "is-lite";
import useTreeChanges from "tree-changes-hook";

// src/modules/store.ts
import deepEqual from "@gilbarbara/deep-equal";
import is3 from "is-lite";
var defaultState2 = {
  action: "init",
  controlled: false,
  index: 0,
  lifecycle: LIFECYCLE.INIT,
  origin: null,
  size: 0,
  status: STATUS.IDLE
};
var Store = class {
  constructor(options) {
    __publicField(this, "beaconPopper");
    __publicField(this, "tooltipPopper");
    __publicField(this, "data", /* @__PURE__ */ new Map());
    __publicField(this, "listener");
    __publicField(this, "props");
    __publicField(this, "store", /* @__PURE__ */ new Map());
    __publicField(this, "updateState", (patch, forceIndex = false) => {
      this.setState({
        ...this.getState(),
        ...this.prepareState(patch, forceIndex)
      });
    });
    __publicField(this, "cleanupPoppers", () => {
      this.beaconPopper = null;
      this.tooltipPopper = null;
    });
    __publicField(this, "getPopper", (name) => {
      if (name === "beacon") {
        return this.beaconPopper;
      }
      return this.tooltipPopper;
    });
    __publicField(this, "setPopper", (popper, type) => {
      var _a, _b;
      if (type === "wrapper") {
        this.beaconPopper = popper;
      } else {
        this.tooltipPopper = popper;
      }
      if (popper && this.store.get("lifecycle") === LIFECYCLE.COMPLETE) {
        this.updateState({
          action: ACTIONS.UPDATE,
          lifecycle: LIFECYCLE.INIT
        });
      }
      const getPopper = (_b = (_a = this.getStep()) == null ? void 0 : _a.floaterProps) == null ? void 0 : _b.getPopper;
      if (getPopper) {
        getPopper(popper, type);
      }
    });
    __publicField(this, "addListener", (listener) => {
      this.listener = listener;
    });
    __publicField(this, "setSteps", (steps) => {
      const { size, status } = this.getState();
      const state = {
        size: steps.length,
        status
      };
      this.data.set("steps", steps);
      if (status === STATUS.WAITING && !size && steps.length) {
        state.status = STATUS.RUNNING;
      }
      this.updateState(state);
    });
    __publicField(this, "close", (origin = null) => {
      const { index, status } = this.getState();
      if (status !== STATUS.RUNNING) {
        return;
      }
      this.updateState({
        action: ACTIONS.CLOSE,
        index: index + 1,
        origin,
        lifecycle: LIFECYCLE.COMPLETE
      });
    });
    __publicField(this, "go", (nextIndex) => {
      const { controlled, status } = this.getState();
      if (controlled || status !== STATUS.RUNNING) {
        return;
      }
      const step = this.getStep(nextIndex);
      this.updateState({
        action: ACTIONS.GO,
        index: nextIndex,
        lifecycle: LIFECYCLE.COMPLETE,
        status: step ? status : STATUS.FINISHED
      });
    });
    __publicField(this, "info", () => this.getState());
    __publicField(this, "next", () => {
      const { index, status } = this.getState();
      if (status !== STATUS.RUNNING) {
        return;
      }
      this.updateState({
        action: ACTIONS.NEXT,
        index: this.getUpdatedIndex(index + 1),
        lifecycle: LIFECYCLE.COMPLETE
      });
    });
    __publicField(this, "open", () => {
      const { status } = this.getState();
      if (status !== STATUS.RUNNING) {
        return;
      }
      this.updateState({ action: ACTIONS.UPDATE, lifecycle: LIFECYCLE.TOOLTIP });
    });
    __publicField(this, "prev", () => {
      const { index, status } = this.getState();
      if (status !== STATUS.RUNNING) {
        return;
      }
      this.updateState({
        action: ACTIONS.PREV,
        index: this.getUpdatedIndex(index - 1),
        lifecycle: LIFECYCLE.COMPLETE
      });
    });
    __publicField(this, "reset", (restart = false) => {
      const { controlled } = this.getState();
      if (controlled) {
        return;
      }
      this.updateState({
        action: ACTIONS.RESET,
        index: 0,
        lifecycle: LIFECYCLE.COMPLETE,
        status: restart ? STATUS.RUNNING : STATUS.READY
      });
    });
    __publicField(this, "skip", () => {
      const { status } = this.getState();
      if (status !== STATUS.RUNNING) {
        return;
      }
      this.updateState({
        action: ACTIONS.SKIP,
        lifecycle: LIFECYCLE.COMPLETE,
        status: STATUS.SKIPPED
      });
    });
    __publicField(this, "start", (nextIndex) => {
      const { index, size } = this.getState();
      this.updateState(
        {
          action: ACTIONS.START,
          index: is3.number(nextIndex) ? nextIndex : index,
          status: size ? STATUS.RUNNING : STATUS.WAITING
        },
        true
      );
    });
    __publicField(this, "stop", (advance = false) => {
      const { index, status } = this.getState();
      if ([STATUS.FINISHED, STATUS.SKIPPED].includes(status)) {
        return;
      }
      this.updateState({
        action: ACTIONS.STOP,
        index: index + (advance ? 1 : 0),
        lifecycle: LIFECYCLE.COMPLETE,
        status: STATUS.PAUSED
      });
    });
    const { continuous = false, stepIndex, steps = [] } = options != null ? options : {};
    this.setState(
      {
        action: ACTIONS.INIT,
        controlled: is3.number(stepIndex),
        continuous,
        index: is3.number(stepIndex) ? stepIndex : 0,
        lifecycle: LIFECYCLE.INIT,
        origin: null,
        status: steps.length ? STATUS.READY : STATUS.IDLE
      },
      true
    );
    this.setSteps(steps);
    this.beaconPopper = null;
    this.tooltipPopper = null;
    this.listener = null;
    this.props = options != null ? options : { steps: [] };
  }
  getStep(nextIndex) {
    const steps = this.data.get("steps");
    const { index } = this.getState();
    return getMergedStep(this.props, steps[nextIndex != null ? nextIndex : index]);
  }
  getUpdatedIndex(nextIndex) {
    const { size } = this.getState();
    return Math.min(Math.max(nextIndex, 0), size);
  }
  hasUpdatedState(oldState) {
    return !deepEqual(oldState, this.getState());
  }
  prepareState(patch, forceIndex = false) {
    var _a, _b, _c, _d, _e, _f;
    const { action, controlled, index, size, status } = this.getState();
    const newIndex = (_a = patch.index) != null ? _a : index;
    return {
      action: (_b = patch.action) != null ? _b : action,
      controlled,
      index: controlled && !forceIndex ? index : newIndex,
      lifecycle: (_c = patch.lifecycle) != null ? _c : LIFECYCLE.INIT,
      origin: (_d = patch.origin) != null ? _d : null,
      size: (_e = patch.size) != null ? _e : size,
      status: (_f = patch.status) != null ? _f : status
    };
  }
  setState(patch, initial = false) {
    const state = this.getState();
    const {
      action,
      index,
      lifecycle,
      origin = null,
      size,
      status
    } = {
      ...state,
      ...patch
    };
    this.store.set("action", action);
    this.store.set("index", index);
    this.store.set("lifecycle", lifecycle);
    this.store.set("origin", origin);
    this.store.set("size", size);
    this.store.set("status", status);
    if (initial) {
      this.store.set("controlled", patch.controlled);
      this.store.set("continuous", patch.continuous);
    }
    if (this.listener && this.hasUpdatedState(state)) {
      this.listener(this.getState());
    }
  }
  getState() {
    var _a;
    if (!((_a = this == null ? void 0 : this.store) == null ? void 0 : _a.size)) {
      return { ...defaultState2 };
    }
    return {
      action: this.store.get("action") || "",
      controlled: this.store.get("controlled") || false,
      index: parseInt(this.store.get("index"), 10),
      lifecycle: this.store.get("lifecycle") || "",
      origin: this.store.get("origin") || null,
      size: this.store.get("size") || 0,
      status: this.store.get("status") || ""
    };
  }
  getHelpers() {
    return {
      close: this.close,
      go: this.go,
      info: this.info,
      next: this.next,
      open: this.open,
      prev: this.prev,
      reset: this.reset,
      skip: this.skip
    };
  }
};
function createStore(options) {
  return new Store(options);
}

// src/modules/useJoyrideData.ts
function useJoyrideData(props) {
  const {
    callback,
    continuous,
    debug,
    disableScrollParentFix,
    getHelpers,
    run,
    scrollDuration,
    scrollOffset,
    scrollToFirstStep,
    stepIndex,
    steps
  } = props;
  const store = useRef(createStore(props));
  const [state, setState] = useSetState(store.current.getState());
  const { action, controlled, index, lifecycle, size, status } = state;
  const lastAction = useRef(null);
  const previousProps = usePrevious(props);
  const previousState = usePrevious(state);
  const { changed: changedProps } = useTreeChanges(props);
  const { changed: changedState, changedFrom: changedStateFrom } = useTreeChanges(state);
  const step = useMemo(() => getMergedStep(props, steps[index]), [index, props, steps]);
  const previousStep = useMemo(() => getMergedStep(props, steps[index - 1]), [index, props, steps]);
  useSingleton(() => {
    store.current.addListener((newState) => {
      setState(newState);
    });
  });
  const scrollToStep = useCallback(
    (lastState) => {
      var _a, _b, _c, _d, _e, _f;
      if (!step) {
        return;
      }
      const target = getElement(step.target);
      const shouldScrollToStep = shouldScroll({
        isFirstStep: index === 0,
        lifecycle,
        previousLifecycle: lastState.lifecycle,
        scrollToFirstStep,
        step,
        target
      });
      const beaconPopper = store.current.getPopper("beacon");
      const tooltipPopper = store.current.getPopper("tooltip");
      if (status === STATUS.RUNNING && shouldScrollToStep) {
        const hasCustomScroll = hasCustomScrollParent(target, disableScrollParentFix);
        const scrollParent2 = getScrollParent(target, disableScrollParentFix);
        let scrollY = Math.floor(getScrollTo(target, scrollOffset, disableScrollParentFix)) || 0;
        log({
          title: "scrollToStep",
          data: [
            { key: "index", value: index },
            { key: "lifecycle", value: lifecycle },
            { key: "status", value: status }
          ],
          debug
        });
        if (lifecycle === LIFECYCLE.BEACON && beaconPopper) {
          const { modifiersData, placement } = (_a = beaconPopper.state) != null ? _a : {};
          const { offset } = modifiersData != null ? modifiersData : {};
          const y = (_c = (_b = offset == null ? void 0 : offset.top) == null ? void 0 : _b.y) != null ? _c : 0;
          if (!["bottom"].includes(placement) && !hasCustomScroll) {
            scrollY = Math.floor(y - scrollOffset);
          }
        } else if (lifecycle === LIFECYCLE.TOOLTIP && tooltipPopper) {
          const { modifiersData, placement } = (_d = tooltipPopper.state) != null ? _d : {};
          const { offset } = modifiersData != null ? modifiersData : {};
          const y = (_f = (_e = offset == null ? void 0 : offset.top) == null ? void 0 : _e.y) != null ? _f : 0;
          const flipped = !!placement && placement !== step.placement;
          if (["top", "right", "left"].includes(placement) && !flipped && !hasCustomScroll) {
            scrollY = Math.floor(y - scrollOffset);
          } else {
            scrollY -= step.spotlightPadding;
          }
        }
        scrollY = scrollY >= 0 ? scrollY : 0;
        if (status === STATUS.RUNNING) {
          scrollTo(scrollY, { element: scrollParent2, duration: scrollDuration }).then(
            () => {
              setTimeout(() => {
                var _a2;
                (_a2 = store.current.getPopper("tooltip")) == null ? void 0 : _a2.update();
              }, 10);
            }
          );
        }
      }
    },
    [
      debug,
      disableScrollParentFix,
      index,
      lifecycle,
      scrollDuration,
      scrollOffset,
      scrollToFirstStep,
      status,
      step
    ]
  );
  useMount(() => {
    if (run && size && validateSteps(steps, debug)) {
      store.current.start();
    }
    if (getHelpers) {
      getHelpers(store.current.getHelpers());
    }
  });
  useUpdateEffect(() => {
    if (run && size && status === STATUS.IDLE) {
      store.current.updateState({ status: STATUS.READY });
    }
    if (getHelpers) {
      getHelpers(store.current.getHelpers());
    }
  }, [getHelpers, run, size, status]);
  useDeepCompareEffect(() => {
    var _a, _b, _c, _d;
    if (!previousProps || !previousState) {
      return;
    }
    const isAfterAction = changedState("action", [
      ACTIONS.NEXT,
      ACTIONS.PREV,
      ACTIONS.SKIP,
      ACTIONS.CLOSE
    ]);
    if (isAfterAction || lastAction.current === ACTIONS.CLOSE && action === ACTIONS.START) {
      lastAction.current = action;
    }
    if (status === STATUS.RUNNING && step && lifecycle === LIFECYCLE.INIT) {
      store.current.updateState({
        action: (_a = lastAction.current) != null ? _a : ACTIONS.UPDATE,
        lifecycle: LIFECYCLE.READY
      });
    }
    if (size && !step && lifecycle === LIFECYCLE.INIT) {
      store.current.updateState({
        action: ACTIONS.UPDATE,
        lifecycle: LIFECYCLE.COMPLETE,
        status: STATUS.FINISHED
      });
    }
    if (status === STATUS.RUNNING && (step == null ? void 0 : step.placement) === "center" && changedState("lifecycle", LIFECYCLE.COMPLETE)) {
      store.current.updateState({ action: ACTIONS.UPDATE, lifecycle: LIFECYCLE.INIT });
    }
    const element = getElement(step == null ? void 0 : step.target);
    const elementExists = !!element;
    if (step && elementExists && isElementVisible(element)) {
      if (changedStateFrom("lifecycle", LIFECYCLE.INIT, LIFECYCLE.READY)) {
        callback == null ? void 0 : callback({
          ...state,
          action: (_b = lastAction.current) != null ? _b : action,
          step,
          type: EVENTS.STEP_BEFORE
        });
      }
    } else if (step && status === STATUS.RUNNING) {
      console.warn(elementExists ? "Target not visible" : "Target not mounted", step);
      callback == null ? void 0 : callback({
        ...state,
        type: EVENTS.TARGET_NOT_FOUND,
        step
      });
      if (!controlled) {
        store.current.updateState({
          action: ACTIONS.UPDATE,
          index: index + (action === ACTIONS.PREV ? -1 : 1)
        });
      }
    }
    if (step && changedState("lifecycle", LIFECYCLE.READY)) {
      store.current.updateState({
        action: ACTIONS.UPDATE,
        lifecycle: hideBeacon(step, state, continuous) ? LIFECYCLE.TOOLTIP : LIFECYCLE.BEACON
      });
    }
    if (step && changedState("lifecycle", LIFECYCLE.BEACON)) {
      callback == null ? void 0 : callback({
        ...state,
        step,
        type: EVENTS.BEACON
      });
    }
    if (step && changedState("lifecycle", LIFECYCLE.TOOLTIP)) {
      callback == null ? void 0 : callback({
        ...state,
        step,
        type: EVENTS.TOOLTIP
      });
    }
    const isRunningOrPausedWithStep = status === STATUS.RUNNING || controlled && status === STATUS.PAUSED && !!step;
    const callbackStep = step != null ? step : previousStep;
    const shouldSendCallback = isRunningOrPausedWithStep && callbackStep && changedState("lifecycle", LIFECYCLE.COMPLETE, LIFECYCLE.TOOLTIP) && (elementExists || !step);
    if (shouldSendCallback) {
      callback == null ? void 0 : callback({
        ...state,
        action: (_c = lastAction.current) != null ? _c : ACTIONS.UPDATE,
        index: (_d = previousState.index) != null ? _d : index,
        lifecycle,
        step: callbackStep,
        type: EVENTS.STEP_AFTER
      });
    }
    if (status === STATUS.WAITING) {
      store.current.updateState({ status: STATUS.RUNNING });
    }
    if (changedProps()) {
      const { stepIndex: previousStepIndex, steps: previousSteps } = previousProps;
      if (!isEqual(previousSteps, steps)) {
        if (validateSteps(steps, debug)) {
          store.current.updateState({ size: steps.length });
        } else {
          console.warn("Steps are not valid", steps);
        }
      }
      if (changedProps("run")) {
        if (run) {
          if (store.current.getState().size) {
            store.current.start(stepIndex);
          }
        } else {
          store.current.stop();
        }
      } else if (is4.number(stepIndex) && changedProps("stepIndex")) {
        const nextAction = is4.number(previousStepIndex) && previousStepIndex < stepIndex ? ACTIONS.NEXT : ACTIONS.PREV;
        if (![STATUS.FINISHED, STATUS.SKIPPED].includes(status)) {
          store.current.updateState({ action: nextAction, index: stepIndex }, true);
        }
      }
    }
    if (changedState("index")) {
      log({
        title: `step:${lifecycle}`,
        data: [{ key: "props", value: props }],
        debug
      });
    }
    if (changedState("lifecycle", LIFECYCLE.COMPLETE) && index && index >= size) {
      store.current.updateState({
        action: ACTIONS.UPDATE,
        lifecycle: LIFECYCLE.COMPLETE,
        status: STATUS.FINISHED
      });
    }
    if (previousStep && changedState("status", [STATUS.FINISHED, STATUS.SKIPPED])) {
      callback == null ? void 0 : callback({
        ...state,
        index: index - 1,
        // Return the last step when the tour is finished
        step: previousStep,
        type: EVENTS.TOUR_END
      });
      store.current.reset();
    }
    if (step && changedStateFrom("status", [STATUS.IDLE, STATUS.READY, STATUS.PAUSED], STATUS.RUNNING)) {
      callback == null ? void 0 : callback({
        ...state,
        step,
        type: EVENTS.TOUR_START
      });
    }
    if (step && changedState("action", ACTIONS.STOP)) {
      callback == null ? void 0 : callback({
        ...state,
        step,
        type: EVENTS.TOUR_STATUS
      });
    }
    if (step && changedState("action", ACTIONS.RESET)) {
      callback == null ? void 0 : callback({
        ...state,
        step,
        type: EVENTS.TOUR_STATUS
      });
    }
    scrollToStep(previousState);
  }, [
    action,
    callback,
    changedProps,
    changedState,
    changedStateFrom,
    continuous,
    controlled,
    debug,
    index,
    lifecycle,
    previousProps,
    previousState,
    previousStep,
    props,
    run,
    scrollToStep,
    size,
    state,
    status,
    step,
    stepIndex,
    steps
  ]);
  return store;
}

// src/modules/usePortalElement.ts
import { useMount as useMount2, useSetState as useSetState2, useUnmount } from "@gilbarbara/hooks";
import is5 from "is-lite";
function usePortalElement(portalElement) {
  const [{ element, useExternalPortal }, setState] = useSetState2({
    useExternalPortal: false,
    element: null
  });
  useMount2(() => {
    if (portalElement) {
      if (is5.domElement(portalElement)) {
        setState({ element: portalElement, useExternalPortal: true });
      } else {
        const portal = document.querySelector(portalElement);
        if (portal) {
          setState({ element: portal });
        }
      }
    }
    if (!portalElement) {
      const portal = document.createElement("div");
      portal.id = PORTAL_ELEMENT_ID;
      document.body.appendChild(portal);
      setState({ element: portal });
    }
  });
  useUnmount(() => {
    if (!element || useExternalPortal) {
      return;
    }
    if (element.parentNode === document.body) {
      document.body.removeChild(element);
    }
  });
  return element;
}

// src/components/Overlay.tsx
import { useCallback as useCallback2, useEffect, useMemo as useMemo2, useRef as useRef2 } from "react";
import { useIsMounted, useMount as useMount3, useSetState as useSetState3, useUnmount as useUnmount2 } from "@gilbarbara/hooks";
import useTreeChanges2 from "tree-changes-hook";

// src/components/Spotlight.tsx
import { jsx } from "react/jsx-runtime";
function JoyrideSpotlight({ styles }) {
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: "react-joyride__spotlight",
      "data-test-id": "spotlight",
      style: styles
    },
    "JoyrideSpotlight"
  );
}

// src/components/Overlay.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
function JoyrideOverlay(props) {
  const {
    continuous,
    debug,
    disableOverlay,
    disableOverlayClose,
    disableScrolling,
    disableScrollParentFix = false,
    lifecycle,
    onClickOverlay,
    placement,
    spotlightClicks,
    spotlightPadding = 0,
    styles,
    target
  } = props;
  const isMounted = useIsMounted();
  const { changed } = useTreeChanges2(props);
  const resizeTimeoutRef = useRef2();
  const scrollTimeoutRef = useRef2();
  const scrollParentRef = useRef2(null);
  const [{ isScrolling, mouseOverSpotlight, showSpotlight }, setState] = useSetState3({
    isScrolling: false,
    mouseOverSpotlight: false,
    resizedAt: 0,
    showSpotlight: true
  });
  const updateState = useCallback2(
    (state) => {
      if (!isMounted) {
        return;
      }
      setState(state);
    },
    [isMounted, setState]
  );
  const overlayStyles = useMemo2(() => {
    let baseStyles = styles.overlay;
    if (isLegacy()) {
      baseStyles = placement === "center" ? styles.overlayLegacyCenter : styles.overlayLegacy;
    }
    return {
      cursor: disableOverlayClose ? "default" : "pointer",
      height: getDocumentHeight(),
      pointerEvents: mouseOverSpotlight ? "none" : "auto",
      ...baseStyles
    };
  }, [
    disableOverlayClose,
    mouseOverSpotlight,
    placement,
    styles.overlay,
    styles.overlayLegacy,
    styles.overlayLegacyCenter
  ]);
  const spotlightStyles = useMemo2(() => {
    var _a, _b, _c;
    const element = getElement(target);
    const elementRect = getClientRect(element);
    const isFixedTarget = hasPosition(element);
    const top = getElementPosition(element, spotlightPadding, disableScrollParentFix);
    return {
      height: Math.round(((_a = elementRect == null ? void 0 : elementRect.height) != null ? _a : 0) + spotlightPadding * 2),
      left: Math.round(((_b = elementRect == null ? void 0 : elementRect.left) != null ? _b : 0) - spotlightPadding),
      opacity: showSpotlight ? 1 : 0,
      pointerEvents: spotlightClicks ? "none" : "auto",
      position: isFixedTarget ? "fixed" : "absolute",
      top,
      transition: "opacity 0.2s",
      width: Math.round(((_c = elementRect == null ? void 0 : elementRect.width) != null ? _c : 0) + spotlightPadding * 2),
      ...isLegacy() ? styles.spotlightLegacy : styles.spotlight
    };
  }, [
    disableScrollParentFix,
    showSpotlight,
    spotlightClicks,
    spotlightPadding,
    styles.spotlight,
    styles.spotlightLegacy,
    target
  ]);
  const handleMouseMove = useCallback2(
    (event) => {
      const { height, left, position, top, width } = spotlightStyles;
      const offsetY = position === "fixed" ? event.clientY : event.pageY;
      const offsetX = position === "fixed" ? event.clientX : event.pageX;
      const inSpotlightHeight = offsetY >= top && offsetY <= top + height;
      const inSpotlightWidth = offsetX >= left && offsetX <= left + width;
      const inSpotlight = inSpotlightWidth && inSpotlightHeight;
      if (inSpotlight !== mouseOverSpotlight) {
        updateState({ mouseOverSpotlight: inSpotlight });
      }
    },
    [spotlightStyles, mouseOverSpotlight, updateState]
  );
  const handleResize = useCallback2(() => {
    clearTimeout(resizeTimeoutRef.current);
    resizeTimeoutRef.current = window.setTimeout(() => {
      if (!isMounted) {
        return;
      }
      setState({ resizedAt: Date.now() });
    }, 100);
  }, [isMounted, setState]);
  const handleScroll = useCallback2(() => {
    const element = getElement(target);
    if (scrollParentRef.current !== document) {
      if (!isScrolling) {
        updateState({ isScrolling: true, showSpotlight: false });
      }
      clearTimeout(scrollTimeoutRef.current);
      scrollTimeoutRef.current = window.setTimeout(() => {
        updateState({ isScrolling: false, showSpotlight: true });
      }, 50);
    } else if (hasPosition(element, "sticky")) {
      updateState({});
    }
  }, [isScrolling, target, updateState]);
  useMount3(() => {
    const element = getElement(target);
    scrollParentRef.current = getScrollParent(
      element != null ? element : document.body,
      disableScrollParentFix,
      true
    );
    if (process.env.NODE_ENV !== "production") {
      if (!disableScrolling && hasCustomScrollParent(element, true)) {
        log({
          title: "step has a custom scroll parent and can cause trouble with scrolling",
          data: [{ key: "parent", value: scrollParentRef }],
          debug
        });
      }
    }
    window.addEventListener("resize", handleResize);
  });
  useUnmount2(() => {
    var _a;
    window.removeEventListener("mousemove", handleMouseMove);
    window.removeEventListener("resize", handleResize);
    clearTimeout(resizeTimeoutRef.current);
    clearTimeout(scrollTimeoutRef.current);
    (_a = scrollParentRef == null ? void 0 : scrollParentRef.current) == null ? void 0 : _a.removeEventListener("scroll", handleScroll);
  });
  useEffect(() => {
    var _a;
    if (changed("lifecycle", LIFECYCLE.TOOLTIP)) {
      (_a = scrollParentRef == null ? void 0 : scrollParentRef.current) == null ? void 0 : _a.addEventListener("scroll", handleScroll, { passive: true });
      setTimeout(() => {
        if (!isScrolling) {
          updateState({ showSpotlight: true });
        }
      }, 100);
    }
  }, [changed, handleScroll, isScrolling, updateState]);
  useEffect(() => {
    if (changed("spotlightClicks") || changed("disableOverlay") || changed("lifecycle")) {
      if (spotlightClicks && lifecycle === LIFECYCLE.TOOLTIP) {
        window.addEventListener("mousemove", handleMouseMove, false);
      } else if (lifecycle !== LIFECYCLE.TOOLTIP) {
        window.removeEventListener("mousemove", handleMouseMove);
      }
    }
  }, [changed, handleMouseMove, lifecycle, spotlightClicks]);
  useEffect(() => {
    if (changed("target") || changed("disableScrollParentFix")) {
      const element = getElement(target);
      scrollParentRef.current = getScrollParent(
        element != null ? element : document.body,
        disableScrollParentFix,
        true
      );
    }
  }, [changed, disableScrollParentFix, target]);
  const hiddenLifecycles = [
    LIFECYCLE.INIT,
    LIFECYCLE.BEACON,
    LIFECYCLE.COMPLETE,
    LIFECYCLE.ERROR
  ];
  if (disableOverlay || (continuous ? hiddenLifecycles.includes(lifecycle) : lifecycle !== LIFECYCLE.TOOLTIP)) {
    return null;
  }
  let spotlight2 = placement !== "center" && showSpotlight && /* @__PURE__ */ jsx2(JoyrideSpotlight, { styles: spotlightStyles });
  const actualOverlayStyles = { ...overlayStyles };
  if (getBrowser() === "safari") {
    const { mixBlendMode, zIndex, ...safariOverlay } = overlayStyles;
    spotlight2 = /* @__PURE__ */ jsx2("div", { style: { ...safariOverlay }, children: spotlight2 });
    delete actualOverlayStyles.backgroundColor;
  }
  return /* @__PURE__ */ jsx2(
    "div",
    {
      className: "react-joyride__overlay",
      "data-test-id": "overlay",
      onClick: onClickOverlay,
      role: "presentation",
      style: actualOverlayStyles,
      children: spotlight2
    }
  );
}

// src/components/Portal.tsx
import { createPortal } from "react-dom";
function JoyridePortal(props) {
  const { children, element } = props;
  if (!element) {
    return null;
  }
  return createPortal(children, element);
}

// src/components/Step.tsx
import { useEffect as useEffect2, useRef as useRef4 } from "react";
import Floater from "react-floater";
import { useMount as useMount5, useUnmount as useUnmount4 } from "@gilbarbara/hooks";
import is7 from "is-lite";
import useTreeChanges3 from "tree-changes-hook";

// src/modules/scope.ts
var Scope = class {
  constructor(element, options) {
    __publicField(this, "element");
    __publicField(this, "options");
    __publicField(this, "canBeTabbed", (element) => {
      const { tabIndex } = element;
      if (tabIndex === null || tabIndex < 0) {
        return false;
      }
      return this.canHaveFocus(element);
    });
    __publicField(this, "canHaveFocus", (element) => {
      const validTabNodes = /input|select|textarea|button|object/;
      const nodeName = element.nodeName.toLowerCase();
      const isValid = validTabNodes.test(nodeName) && !element.getAttribute("disabled") || nodeName === "a" && !!element.getAttribute("href");
      return isValid && this.isVisible(element);
    });
    __publicField(this, "findValidTabElements", () => [].slice.call(this.element.querySelectorAll("*"), 0).filter(this.canBeTabbed));
    __publicField(this, "handleKeyDown", (event) => {
      const { code = "Tab" } = this.options;
      if (event.code === code) {
        this.interceptTab(event);
      }
    });
    __publicField(this, "interceptTab", (event) => {
      event.preventDefault();
      const elements = this.findValidTabElements();
      const { shiftKey } = event;
      if (!elements.length) {
        return;
      }
      let x = document.activeElement ? elements.indexOf(document.activeElement) : 0;
      if (x === -1 || !shiftKey && x + 1 === elements.length) {
        x = 0;
      } else if (shiftKey && x === 0) {
        x = elements.length - 1;
      } else {
        x += shiftKey ? -1 : 1;
      }
      elements[x].focus();
    });
    // eslint-disable-next-line class-methods-use-this
    __publicField(this, "isHidden", (element) => {
      const noSize = element.offsetWidth <= 0 && element.offsetHeight <= 0;
      const style = window.getComputedStyle(element);
      if (noSize && !element.innerHTML) {
        return true;
      }
      return noSize && style.getPropertyValue("overflow") !== "visible" || style.getPropertyValue("display") === "none";
    });
    __publicField(this, "isVisible", (element) => {
      let parentElement = element;
      while (parentElement) {
        if (parentElement instanceof HTMLElement) {
          if (parentElement === document.body) {
            break;
          }
          if (this.isHidden(parentElement)) {
            return false;
          }
          parentElement = parentElement.parentNode;
        }
      }
      return true;
    });
    __publicField(this, "removeScope", () => {
      window.removeEventListener("keydown", this.handleKeyDown);
    });
    __publicField(this, "checkFocus", (target) => {
      if (document.activeElement !== target) {
        target.focus();
        window.requestAnimationFrame(() => this.checkFocus(target));
      }
    });
    __publicField(this, "setFocus", () => {
      const { selector } = this.options;
      if (!selector) {
        return;
      }
      const target = this.element.querySelector(selector);
      if (target) {
        window.requestAnimationFrame(() => this.checkFocus(target));
      }
    });
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Invalid parameter: element must be an HTMLElement");
    }
    this.element = element;
    this.options = options;
    window.addEventListener("keydown", this.handleKeyDown, false);
    this.setFocus();
  }
};

// src/components/Beacon.tsx
import { useRef as useRef3 } from "react";
import { useMount as useMount4, useSingleton as useSingleton2, useUnmount as useUnmount3 } from "@gilbarbara/hooks";
import is6 from "is-lite";
import { jsx as jsx3, jsxs } from "react/jsx-runtime";
function JoyrideBeacon(props) {
  const {
    beaconComponent,
    continuous,
    index,
    isLastStep,
    locale,
    onClickOrHover,
    shouldFocus,
    size,
    step,
    styles
  } = props;
  const beaconRef = useRef3(null);
  useSingleton2(() => {
    if (beaconComponent) {
      return;
    }
    const head = document.head || document.getElementsByTagName("head")[0];
    const style = document.createElement("style");
    style.id = "joyride-beacon-animation";
    if (props.nonce) {
      style.setAttribute("nonce", props.nonce);
    }
    const css = `
        @keyframes joyride-beacon-inner {
          20% {
            opacity: 0.9;
          }
        
          90% {
            opacity: 0.7;
          }
        }
        
        @keyframes joyride-beacon-outer {
          0% {
            transform: scale(1);
          }
        
          45% {
            opacity: 0.7;
            transform: scale(0.75);
          }
        
          100% {
            opacity: 0.9;
            transform: scale(1);
          }
        }
      `;
    style.appendChild(document.createTextNode(css));
    head.appendChild(style);
  });
  useMount4(() => {
    if (process.env.NODE_ENV !== "production") {
      if (!is6.domElement(beaconRef.current)) {
        console.warn("beacon is not a valid DOM element");
      }
    }
    setTimeout(() => {
      if (is6.domElement(beaconRef.current) && shouldFocus) {
        beaconRef.current.focus();
      }
    }, 0);
  });
  useUnmount3(() => {
    const style = document.getElementById("joyride-beacon-animation");
    if (style == null ? void 0 : style.parentNode) {
      style.parentNode.removeChild(style);
    }
  });
  const setBeaconRef = (el) => {
    beaconRef.current = el;
  };
  const title = getReactNodeText(locale.open);
  const sharedProps = {
    "aria-label": title,
    onClick: onClickOrHover,
    onMouseEnter: onClickOrHover,
    ref: setBeaconRef,
    title
  };
  let component;
  if (beaconComponent) {
    const BeaconComponent = beaconComponent;
    component = /* @__PURE__ */ jsx3(
      BeaconComponent,
      {
        continuous,
        index,
        isLastStep,
        size,
        step,
        ...sharedProps
      }
    );
  } else {
    component = /* @__PURE__ */ jsxs(
      "button",
      {
        className: "react-joyride__beacon",
        "data-test-id": "button-beacon",
        style: styles.beacon,
        type: "button",
        ...sharedProps,
        children: [
          /* @__PURE__ */ jsx3("span", { style: styles.beaconInner }),
          /* @__PURE__ */ jsx3("span", { style: styles.beaconOuter })
        ]
      },
      "JoyrideBeacon"
    );
  }
  return component;
}

// src/components/Tooltip/CloseButton.tsx
import { jsx as jsx4 } from "react/jsx-runtime";
function JoyrideTooltipCloseButton({ styles, ...props }) {
  const { color, height, width, ...style } = styles;
  return /* @__PURE__ */ jsx4("button", { style, type: "button", ...props, children: /* @__PURE__ */ jsx4(
    "svg",
    {
      height: typeof height === "number" ? `${height}px` : height,
      preserveAspectRatio: "xMidYMid",
      version: "1.1",
      viewBox: "0 0 18 18",
      width: typeof width === "number" ? `${width}px` : width,
      xmlns: "http://www.w3.org/2000/svg",
      children: /* @__PURE__ */ jsx4("g", { children: /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M8.13911129,9.00268191 L0.171521827,17.0258467 C-0.0498027049,17.248715 -0.0498027049,17.6098394 0.171521827,17.8327545 C0.28204354,17.9443526 0.427188206,17.9998706 0.572051765,17.9998706 C0.71714958,17.9998706 0.862013139,17.9443526 0.972581703,17.8327545 L9.0000937,9.74924618 L17.0276057,17.8327545 C17.1384085,17.9443526 17.2832721,17.9998706 17.4281356,17.9998706 C17.5729992,17.9998706 17.718097,17.9443526 17.8286656,17.8327545 C18.0499901,17.6098862 18.0499901,17.2487618 17.8286656,17.0258467 L9.86135722,9.00268191 L17.8340066,0.973848225 C18.0553311,0.750979934 18.0553311,0.389855532 17.8340066,0.16694039 C17.6126821,-0.0556467968 17.254037,-0.0556467968 17.0329467,0.16694039 L9.00042166,8.25611765 L0.967006424,0.167268345 C0.745681892,-0.0553188426 0.387317931,-0.0553188426 0.165993399,0.167268345 C-0.0553311331,0.390136635 -0.0553311331,0.751261038 0.165993399,0.974176179 L8.13920499,9.00268191 L8.13911129,9.00268191 Z",
          fill: color
        }
      ) })
    }
  ) });
}

// src/components/Tooltip/Container.tsx
import { jsx as jsx5, jsxs as jsxs2 } from "react/jsx-runtime";
function JoyrideTooltipContainer(props) {
  const { backProps, closeProps, index, isLastStep, primaryProps, skipProps, step, tooltipProps } = props;
  const { content, hideBackButton, hideCloseButton, hideFooter, showSkipButton, styles, title } = step;
  const output = {};
  output.primary = /* @__PURE__ */ jsx5(
    "button",
    {
      "data-test-id": "button-primary",
      style: styles.buttonNext,
      type: "button",
      ...primaryProps
    }
  );
  if (showSkipButton && !isLastStep) {
    output.skip = /* @__PURE__ */ jsx5(
      "button",
      {
        "aria-live": "off",
        "data-test-id": "button-skip",
        style: styles.buttonSkip,
        type: "button",
        ...skipProps
      }
    );
  }
  if (!hideBackButton && index > 0) {
    output.back = /* @__PURE__ */ jsx5("button", { "data-test-id": "button-back", style: styles.buttonBack, type: "button", ...backProps });
  }
  output.close = !hideCloseButton && /* @__PURE__ */ jsx5(JoyrideTooltipCloseButton, { "data-test-id": "button-close", styles: styles.buttonClose, ...closeProps });
  return /* @__PURE__ */ jsxs2(
    "div",
    {
      "aria-label": getReactNodeText(title != null ? title : content),
      className: "react-joyride__tooltip",
      style: styles.tooltip,
      ...tooltipProps,
      children: [
        /* @__PURE__ */ jsxs2("div", { style: styles.tooltipContainer, children: [
          title && /* @__PURE__ */ jsx5("h1", { "aria-label": getReactNodeText(title), style: styles.tooltipTitle, children: title }),
          /* @__PURE__ */ jsx5("div", { style: styles.tooltipContent, children: content })
        ] }),
        !hideFooter && /* @__PURE__ */ jsxs2("div", { style: styles.tooltipFooter, children: [
          /* @__PURE__ */ jsx5("div", { style: styles.tooltipFooterSpacer, children: output.skip }),
          output.back,
          output.primary
        ] }),
        output.close
      ]
    },
    "JoyrideTooltip"
  );
}

// src/components/Tooltip/index.tsx
import { jsx as jsx6 } from "react/jsx-runtime";
function Tooltip(props) {
  const { continuous, helpers, index, isLastStep, setTooltipRef, size, step } = props;
  const handleClickBack = (event) => {
    event.preventDefault();
    helpers.prev();
  };
  const handleClickClose = (event) => {
    event.preventDefault();
    helpers.close("button_close");
  };
  const handleClickPrimary = (event) => {
    event.preventDefault();
    if (!continuous) {
      helpers.close("button_primary");
      return;
    }
    helpers.next();
  };
  const handleClickSkip = (event) => {
    event.preventDefault();
    helpers.skip();
  };
  const getElementsProps = () => {
    const { back, close, last, next, nextLabelWithProgress, skip } = step.locale;
    const backText = getReactNodeText(back);
    const closeText = getReactNodeText(close);
    const lastText = getReactNodeText(last);
    const nextText = getReactNodeText(next);
    const skipText = getReactNodeText(skip);
    let primary = close;
    let primaryText = closeText;
    if (continuous) {
      primary = next;
      primaryText = nextText;
      if (step.showProgress && !isLastStep) {
        const labelWithProgress = getReactNodeText(nextLabelWithProgress, {
          step: index + 1,
          steps: size
        });
        primary = replaceLocaleContent(nextLabelWithProgress, index + 1, size);
        primaryText = labelWithProgress;
      }
      if (isLastStep) {
        primary = last;
        primaryText = lastText;
      }
    }
    return {
      backProps: {
        "aria-label": backText,
        children: back,
        "data-action": "back",
        onClick: handleClickBack,
        role: "button",
        title: backText
      },
      closeProps: {
        "aria-label": closeText,
        children: close,
        "data-action": "close",
        onClick: handleClickClose,
        role: "button",
        title: closeText
      },
      primaryProps: {
        "aria-label": primaryText,
        children: primary,
        "data-action": "primary",
        onClick: handleClickPrimary,
        role: "button",
        title: primaryText
      },
      skipProps: {
        "aria-label": skipText,
        children: skip,
        "data-action": "skip",
        onClick: handleClickSkip,
        role: "button",
        title: skipText
      },
      tooltipProps: {
        "aria-modal": true,
        ref: setTooltipRef,
        role: "alertdialog"
      }
    };
  };
  const { beaconComponent, tooltipComponent, ...cleanStep } = step;
  let component;
  if (tooltipComponent) {
    const renderProps = {
      ...getElementsProps(),
      continuous,
      index,
      isLastStep,
      size,
      step: cleanStep,
      setTooltipRef
    };
    const TooltipComponent = tooltipComponent;
    component = /* @__PURE__ */ jsx6(TooltipComponent, { ...renderProps });
  } else {
    component = /* @__PURE__ */ jsx6(
      JoyrideTooltipContainer,
      {
        ...getElementsProps(),
        continuous,
        index,
        isLastStep,
        size,
        step
      }
    );
  }
  return component;
}

// src/components/Step.tsx
import { jsx as jsx7 } from "react/jsx-runtime";
function JoyrideStep(props) {
  const {
    cleanupPoppers,
    continuous,
    debug,
    helpers,
    index,
    lifecycle,
    nonce,
    setPopper,
    shouldScroll: shouldScroll2,
    size,
    step,
    updateState
  } = props;
  const scopeRef = useRef4(null);
  const tooltipRef = useRef4(null);
  const { changed, changedFrom } = useTreeChanges3(props);
  useMount5(() => {
    log({
      title: `step:${index}`,
      data: [{ key: "props", value: props }],
      debug
    });
  });
  useUnmount4(() => {
    var _a;
    (_a = scopeRef.current) == null ? void 0 : _a.removeScope();
  });
  useEffect2(() => {
    var _a;
    if (changed("lifecycle", LIFECYCLE.TOOLTIP)) {
      if (shouldScroll2 && tooltipRef.current) {
        scopeRef.current = new Scope(tooltipRef.current, { selector: "[data-action=primary]" });
        scopeRef.current.setFocus();
      }
    }
    if (changedFrom("lifecycle", [LIFECYCLE.TOOLTIP, LIFECYCLE.INIT], LIFECYCLE.INIT)) {
      (_a = scopeRef.current) == null ? void 0 : _a.removeScope();
      cleanupPoppers();
    }
  }, [changed, changedFrom, cleanupPoppers, shouldScroll2]);
  const handleClickHoverBeacon = (event) => {
    if (event.type === "mouseenter" && step.event !== "hover") {
      return;
    }
    updateState({ lifecycle: LIFECYCLE.TOOLTIP });
  };
  const setTooltipRef = (element) => {
    tooltipRef.current = element;
  };
  const target = getElement(step.target);
  if (!validateStep(step) || !is7.domElement(target)) {
    return null;
  }
  const tooltip = (renderProps) => {
    return /* @__PURE__ */ jsx7(
      Tooltip,
      {
        continuous,
        helpers,
        index,
        isLastStep: index + 1 === size,
        setTooltipRef,
        size,
        step,
        ...renderProps
      }
    );
  };
  return /* @__PURE__ */ jsx7("div", { className: "react-joyride__step", children: /* @__PURE__ */ jsx7(
    Floater,
    {
      ...step.floaterProps,
      component: tooltip,
      debug,
      getPopper: setPopper,
      id: `react-joyride-step-${index}`,
      open: lifecycle === LIFECYCLE.TOOLTIP,
      placement: step.placement,
      portalElement: `#${PORTAL_ELEMENT_ID}`,
      target: step.target,
      children: /* @__PURE__ */ jsx7(
        JoyrideBeacon,
        {
          beaconComponent: step.beaconComponent,
          continuous,
          index,
          isLastStep: index + 1 === size,
          locale: step.locale,
          nonce,
          onClickOrHover: handleClickHoverBeacon,
          shouldFocus: shouldScroll2,
          size,
          step,
          styles: step.styles
        }
      )
    },
    `JoyrideStep-${index}`
  ) });
}

// src/index.tsx
import { jsx as jsx8, jsxs as jsxs3 } from "react/jsx-runtime";
function Joyride(props) {
  const mergedProps = mergeProps(defaultProps, props);
  const { continuous, debug, disableCloseOnEsc, nonce, portalElement, scrollToFirstStep, steps } = mergedProps;
  const store = useJoyrideData(mergedProps);
  const element = usePortalElement(portalElement);
  useSingleton3(() => {
    log({
      title: "init",
      data: [
        { key: "props", value: props },
        { key: "state", value: store.current.getState() }
      ],
      debug
    });
  });
  useEffect3(() => {
    const handleKeyboard = (event) => {
      const { index: index2, lifecycle: lifecycle2 } = store.current.getState();
      const step2 = steps[index2];
      if (lifecycle2 === LIFECYCLE.TOOLTIP) {
        if (event.code === "Escape" && !step2.disableCloseOnEsc) {
          store.current.close("keyboard");
        }
      }
    };
    if (!disableCloseOnEsc) {
      document.body.addEventListener("keydown", handleKeyboard, { passive: true });
    }
    return () => {
      if (!disableCloseOnEsc) {
        document.body.removeEventListener("keydown", handleKeyboard);
      }
    };
  }, [disableCloseOnEsc, steps, store]);
  const { index, lifecycle, status } = store.current.getState();
  const isRunning = status === STATUS.RUNNING;
  const content = {};
  const step = useMemo3(() => getMergedStep(props, steps[index]), [index, props, steps]);
  const handleClickOverlay = () => {
    if (!(step == null ? void 0 : step.disableOverlayClose)) {
      store.current.close("overlay");
    }
  };
  if (!step) {
    return null;
  }
  if (isRunning) {
    content.step = /* @__PURE__ */ jsx8(
      JoyrideStep,
      {
        ...store.current.getState(),
        cleanupPoppers: store.current.cleanupPoppers,
        continuous,
        debug,
        helpers: store.current.getHelpers(),
        nonce,
        setPopper: store.current.setPopper,
        shouldScroll: !step.disableScrolling && (index !== 0 || scrollToFirstStep),
        step,
        updateState: store.current.updateState
      }
    );
    content.overlay = /* @__PURE__ */ jsx8(JoyridePortal, { element, children: /* @__PURE__ */ jsx8(
      JoyrideOverlay,
      {
        ...step,
        continuous,
        debug,
        lifecycle,
        onClickOverlay: handleClickOverlay
      }
    ) });
  }
  return /* @__PURE__ */ jsxs3("div", { className: "react-joyride", children: [
    content.step,
    content.overlay
  ] });
}
function ReactJoyride(props) {
  if (!canUseDOM()) {
    return null;
  }
  return /* @__PURE__ */ jsx8(Joyride, { ...props });
}
export {
  ACTIONS,
  EVENTS,
  Joyride,
  LIFECYCLE,
  ORIGIN,
  PORTAL_ELEMENT_ID,
  STATUS,
  ReactJoyride as default
};
//# sourceMappingURL=index.mjs.map