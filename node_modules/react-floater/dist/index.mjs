// src/index.tsx
import { useCallback as useCallback2, useMemo as useMemo2, useReducer, useRef as useRef3 } from "react";
import { createPopper } from "@popperjs/core";
import is5 from "is-lite";
import useTreeChanges from "tree-changes-hook";

// src/components/Floater/index.tsx
import { cloneElement, isValidElement as isValidElement2, memo, useMemo } from "react";

// src/components/Floater/Arrow.tsx
import { jsx } from "react/jsx-runtime";
function FloaterArrow(props) {
  const { arrowRef, placement, styles } = props;
  const {
    arrow: { color, display, length, position, spread }
  } = styles;
  const arrowStyles = { display, position };
  let points;
  let x = spread;
  let y = length;
  if (placement.startsWith("top")) {
    points = `0,0 ${x / 2},${y} ${x},0`;
  } else if (placement.startsWith("bottom")) {
    points = `${x},${y} ${x / 2},0 0,${y}`;
  } else if (placement.startsWith("left")) {
    y = spread;
    x = length;
    points = `0,0 ${x},${y / 2} 0,${y}`;
  } else if (placement.startsWith("right")) {
    y = spread;
    x = length;
    points = `${x},${y} ${x},0 0,${y / 2}`;
  }
  return /* @__PURE__ */ jsx("span", { ref: arrowRef, className: "__floater__arrow", style: arrowStyles, children: /* @__PURE__ */ jsx("svg", { height: y, version: "1.1", width: x, xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsx("polygon", { fill: color, points }) }) });
}

// src/components/Floater/Container.tsx
import { isValidElement } from "react";
import is from "is-lite";

// src/components/Floater/CloseButton.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
function FloaterCloseButton({ onClick, styles }) {
  const { color, height, width, ...style } = styles;
  return /* @__PURE__ */ jsx2("button", { "aria-label": "close", onClick, style, type: "button", children: /* @__PURE__ */ jsx2(
    "svg",
    {
      height: `${height}px`,
      preserveAspectRatio: "xMidYMid",
      version: "1.1",
      viewBox: "0 0 18 18",
      width: `${width}px`,
      xmlns: "http://www.w3.org/2000/svg",
      children: /* @__PURE__ */ jsx2("g", { children: /* @__PURE__ */ jsx2(
        "path",
        {
          d: "M8.13911129,9.00268191 L0.171521827,17.0258467 C-0.0498027049,17.248715 -0.0498027049,17.6098394 0.171521827,17.8327545 C0.28204354,17.9443526 0.427188206,17.9998706 0.572051765,17.9998706 C0.71714958,17.9998706 0.862013139,17.9443526 0.972581703,17.8327545 L9.0000937,9.74924618 L17.0276057,17.8327545 C17.1384085,17.9443526 17.2832721,17.9998706 17.4281356,17.9998706 C17.5729992,17.9998706 17.718097,17.9443526 17.8286656,17.8327545 C18.0499901,17.6098862 18.0499901,17.2487618 17.8286656,17.0258467 L9.86135722,9.00268191 L17.8340066,0.973848225 C18.0553311,0.750979934 18.0553311,0.389855532 17.8340066,0.16694039 C17.6126821,-0.0556467968 17.254037,-0.0556467968 17.0329467,0.16694039 L9.00042166,8.25611765 L0.967006424,0.167268345 C0.745681892,-0.0553188426 0.387317931,-0.0553188426 0.165993399,0.167268345 C-0.0553311331,0.390136635 -0.0553311331,0.751261038 0.165993399,0.974176179 L8.13920499,9.00268191 L8.13911129,9.00268191 Z",
          fill: color
        }
      ) })
    }
  ) });
}

// src/components/Floater/Container.tsx
import { jsx as jsx3, jsxs } from "react/jsx-runtime";
function FloaterContainer(props) {
  const { content, footer, onClick, open, positionWrapper, showCloseButton, styles, title } = props;
  const output = {
    content: isValidElement(content) ? content : /* @__PURE__ */ jsx3("div", { className: "__floater__content", style: styles.content, children: content })
  };
  if (title) {
    output.title = isValidElement(title) ? title : /* @__PURE__ */ jsx3("div", { className: "__floater__title", style: styles.title, children: title });
  }
  if (footer) {
    output.footer = isValidElement(footer) ? footer : /* @__PURE__ */ jsx3("div", { className: "__floater__footer", style: styles.footer, children: footer });
  }
  if ((showCloseButton || positionWrapper) && !is.boolean(open)) {
    output.close = /* @__PURE__ */ jsx3(FloaterCloseButton, { onClick, styles: styles.close });
  }
  return /* @__PURE__ */ jsxs("div", { className: "__floater__container", style: styles.container, children: [
    output.close,
    output.title,
    output.content,
    output.footer
  ] });
}

// src/literals.ts
var POSITIONING_PROPS = ["position", "top", "right", "bottom", "left"];
var STATUS = {
  INIT: "init",
  IDLE: "idle",
  RENDER: "render",
  OPENING: "opening",
  OPEN: "open",
  CLOSING: "closing",
  ERROR: "error"
};

// src/components/Floater/index.tsx
import { jsx as jsx4, jsxs as jsxs2 } from "react/jsx-runtime";
function Floater(props) {
  const {
    component,
    content,
    floaterRef,
    hideArrow,
    id,
    onClick: closeFn,
    placement,
    status,
    styles
  } = props;
  const style = useMemo(() => {
    const {
      arrow: { length },
      floater,
      floaterCentered,
      floaterClosing,
      floaterOpening,
      floaterWithComponent
    } = styles;
    let element = { ...floater };
    if (!hideArrow) {
      if (placement.startsWith("top")) {
        element.padding = `0 0 ${length}px`;
      } else if (placement.startsWith("bottom")) {
        element.padding = `${length}px 0 0`;
      } else if (placement.startsWith("left")) {
        element.padding = `0 ${length}px 0 0`;
      } else if (placement.startsWith("right")) {
        element.padding = `0 0 0 ${length}px`;
      }
    }
    if (status === STATUS.CLOSING) {
      element = { ...element, ...floaterClosing };
    }
    if (status === STATUS.OPENING || status === STATUS.OPEN) {
      element = { ...element, ...floaterOpening };
    }
    if (placement === "center") {
      element = { ...element, ...floaterCentered };
    }
    if (component) {
      element = { ...element, ...floaterWithComponent };
    }
    return element;
  }, [component, hideArrow, placement, status, styles]);
  const shouldRender = ["render", "open", "opening", "closing"].includes(status);
  const output = {};
  const classes = ["__floater"];
  const baseProps = { role: "tooltip" };
  if (component) {
    const componentProps = { closeFn, id, ...baseProps };
    output.content = isValidElement2(component) ? cloneElement(component, componentProps) : component(componentProps);
  } else {
    output.content = /* @__PURE__ */ jsx4(FloaterContainer, { ...props, content });
  }
  if (status === STATUS.OPEN) {
    classes.push("__floater__open");
  }
  if (!hideArrow) {
    output.arrow = /* @__PURE__ */ jsx4(FloaterArrow, { ...props });
  }
  if (!shouldRender) {
    return null;
  }
  return /* @__PURE__ */ jsx4("div", { ref: floaterRef, id, style: { zIndex: styles.options.zIndex }, children: /* @__PURE__ */ jsx4("div", { className: classes.join(" "), style, ...baseProps, children: /* @__PURE__ */ jsxs2("div", { className: "__floater__body", children: [
    output.content,
    output.arrow
  ] }) }) });
}
var Floater_default = memo(Floater);

// src/components/Portal.tsx
import { useCallback, useEffect as useEffect2, useRef as useRef2 } from "react";
import { createPortal } from "react-dom";
import is3 from "is-lite";

// src/modules/helpers.ts
import { deepmerge } from "deepmerge-ts";
import is2 from "is-lite";
var portalId = "react-floater-portal";
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document?.createElement);
}
function enhanceProps(props) {
  return {
    autoOpen: false,
    debug: false,
    disableFlip: false,
    disableHoverToClick: false,
    event: "click",
    eventDelay: 0.4,
    hideArrow: false,
    offset: 15,
    placement: "bottom",
    showCloseButton: false,
    styles: {},
    target: null,
    wrapperOptions: {
      position: false
    },
    ...props
  };
}
function getFallbackPlacements(placement) {
  if (placement.startsWith("left")) {
    return ["top", "bottom"];
  }
  if (placement.startsWith("right")) {
    return ["bottom", "top"];
  }
  return void 0;
}
function getModifiers(modifiers) {
  const defaultOptions2 = {
    flip: {
      name: "flip",
      enabled: true,
      options: {
        padding: 20
      }
    },
    preventOverflow: {
      name: "preventOverflow",
      enabled: true,
      options: {
        padding: 10
      }
    }
  };
  return deepmerge(defaultOptions2, modifiers ?? {});
}
function isFixed(el) {
  if (!el) {
    return false;
  }
  const { nodeName } = el;
  if (nodeName === "BODY" || nodeName === "HTML") {
    return false;
  }
  if (getComputedStyle(el).position === "fixed") {
    return true;
  }
  return el.parentNode instanceof HTMLElement ? isFixed(el.parentNode) : false;
}
function isMobile() {
  return "ontouchstart" in window && /Mobi/.test(navigator.userAgent);
}
function log({ data, debug = false, title }) {
  const logFn = console.log;
  if (debug && title && data) {
    console.groupCollapsed(
      `%creact-floater: ${title}`,
      "color: #9b00ff; font-weight: bold; font-size: 12px;"
    );
    if (Array.isArray(data)) {
      data.forEach((d) => {
        if (is2.plainObject(d) && d.key) {
          logFn.apply(console, [d.key, d.value]);
        } else {
          logFn.apply(console, [d]);
        }
      });
    } else {
      logFn.apply(console, [data]);
    }
    console.groupEnd();
  }
}
function mergeModifier(modifier, customModifier) {
  return deepmerge(modifier, customModifier ?? {});
}
function off(element, eventType, handler, options = false) {
  element.removeEventListener(eventType, handler, options);
}
function on(element, eventType, handler, options = false) {
  element.addEventListener(eventType, handler, options);
}
function once(element, eventType, handler, options = false) {
  let nextCB;
  nextCB = (event) => {
    handler(event);
    off(element, eventType, nextCB);
  };
  on(element, eventType, nextCB, options);
}
function randomId() {
  return `rf-${Math.round(Math.random() * 1e5)}`;
}

// src/modules/hooks.ts
import { useEffect, useRef } from "react";
function useEffectOnce(effect) {
  useEffect(effect, []);
}
function useMount(effect) {
  useEffectOnce(effect);
}
function useSingleton(callback) {
  const hasBeenCalled = useRef(false);
  if (hasBeenCalled.current) {
    return;
  }
  callback();
  hasBeenCalled.current = true;
}
function useUnmount(fn) {
  const fnRef = useRef(fn);
  fnRef.current = fn;
  useEffectOnce(() => () => fnRef.current());
}
function useUpdateEffect(effect, deps) {
  const isFirst = useRef(true);
  useEffect(() => {
    if (!isFirst.current) {
      effect();
    }
  }, deps);
  if (isFirst.current) {
    isFirst.current = false;
  }
}

// src/components/Portal.tsx
function ReactFloaterPortal(props) {
  const { children, hasChildren, internalId, placement, portalElement, target, zIndex } = props;
  const node = useRef2(null);
  const initialize = useCallback(() => {
    if (!canUseDOM()) {
      return;
    }
    if (portalElement) {
      node.current = is3.string(portalElement) ? document.querySelector(portalElement) : portalElement;
    }
    if (!portalElement || !node.current) {
      const portal = document.getElementById(portalId);
      if (portal) {
        const ids = portal.dataset.ids?.split(",").filter(Boolean) ?? [];
        if (!ids.includes(internalId) && internalId) {
          ids.push(internalId);
        }
        portal.dataset.ids = ids.join(",");
        node.current = portal;
      } else {
        node.current = document.createElement("div");
        node.current.id = portalId;
        node.current.dataset.ids = internalId;
        node.current.style.zIndex = `${zIndex}`;
        document.body.appendChild(node.current);
      }
    }
    if (!portalElement && !document.getElementById(portalId)) {
      if (node.current) {
        document.body.appendChild(node.current);
      }
    }
  }, [internalId, portalElement, zIndex]);
  useMount(() => {
    if (!canUseDOM) {
      return;
    }
    initialize();
  });
  useEffect2(() => {
    initialize();
  }, [initialize]);
  useUnmount(() => {
    if (!canUseDOM() || !node.current) {
      return;
    }
    try {
      if (node.current.id === portalId) {
        const ids = node.current.dataset.ids?.split(",") ?? [];
        if (ids.includes(internalId)) {
          node.current.dataset.ids = ids.filter((id) => id !== internalId).join(",");
        }
        if (ids.length <= 1) {
          document.body.removeChild(node.current);
          node.current = null;
        }
      }
    } catch {
      node.current = null;
    }
  });
  if (node.current) {
    if (!hasChildren && !target && placement !== "center") {
      return null;
    }
    return createPortal(children, node.current);
  }
  return null;
}

// src/components/Wrapper.tsx
import {
  Children,
  cloneElement as cloneElement2,
  Fragment,
  isValidElement as isValidElement3,
  memo as memo2
} from "react";
import is4 from "is-lite";
import { jsx as jsx5 } from "react/jsx-runtime";
function FloaterWrapper(props) {
  const {
    childRef,
    children,
    id,
    isControlled,
    onClick,
    onMount,
    onMouseEnter,
    onMouseLeave,
    status,
    style,
    styles,
    wrapperRef
  } = props;
  useMount(() => {
    onMount();
  });
  let element = null;
  const mergedStyles = {
    ...styles,
    ...style,
    ...isValidElement3(children) ? children.props.style : void 0
  };
  const wrapperId = `${id}-wrapper`;
  let wrapperProps = {
    "aria-describedby": [STATUS.OPENING, STATUS.OPEN, STATUS.CLOSING].includes(
      status
    ) ? id : void 0,
    style: mergedStyles
  };
  if (!isControlled) {
    wrapperProps = {
      ...wrapperProps,
      onClick,
      onMouseEnter,
      onMouseLeave
    };
  }
  if (children) {
    if (Children.count(children) === 1 && isValidElement3(children) && children.type !== Fragment) {
      element = is4.function(children.type) ? /* @__PURE__ */ jsx5("span", { ref: wrapperRef, id: wrapperId, ...wrapperProps, children: cloneElement2(Children.only(children), {
        innerRef: childRef
      }) }) : cloneElement2(Children.only(children), {
        id: wrapperId,
        ref: wrapperRef,
        ...wrapperProps
      });
    } else {
      element = /* @__PURE__ */ jsx5("span", { ref: wrapperRef, id: wrapperId, ...wrapperProps, children });
    }
  }
  return element;
}
var Wrapper_default = memo2(FloaterWrapper);

// src/modules/styles.ts
import { deepmerge as deepmerge2 } from "deepmerge-ts";
var defaultOptions = {
  zIndex: 100
};
function getStyles(styles) {
  const { options = {}, ...rest } = styles ?? {};
  return deepmerge2(
    {
      arrow: {
        color: "#fff",
        display: "inline-flex",
        length: 16,
        position: "absolute",
        spread: 32
      },
      close: {
        backgroundColor: "transparent",
        border: 0,
        borderRadius: 0,
        color: "#555",
        fontSize: 0,
        height: 15,
        outline: "none",
        padding: 10,
        position: "absolute",
        right: 0,
        top: 0,
        width: 15,
        WebkitAppearance: "none"
      },
      container: {
        backgroundColor: "#fff",
        color: "#666",
        minHeight: 60,
        minWidth: 200,
        padding: 20,
        position: "relative",
        zIndex: 10
      },
      content: {
        fontSize: 15
      },
      footer: {
        borderTop: "1px solid #ccc",
        fontSize: 13,
        marginTop: 10,
        paddingTop: 5
      },
      floater: {
        display: "inline-block",
        filter: "drop-shadow(0 0 3px rgba(0, 0, 0, 0.3))",
        maxWidth: 300,
        opacity: 0,
        position: "relative",
        transition: "opacity 0.3s",
        visibility: "hidden",
        zIndex: options.zIndex
      },
      floaterCentered: {
        left: "50%",
        position: "fixed",
        top: "50%",
        transform: "translate(-50%, -50%)"
      },
      floaterClosing: {
        opacity: 0,
        visibility: "visible"
      },
      floaterOpening: {
        opacity: 1,
        visibility: "visible"
      },
      floaterWithComponent: {
        maxWidth: "100%"
      },
      title: {
        borderBottom: "1px solid #555",
        color: "#555",
        fontSize: 18,
        marginBottom: 5,
        paddingBottom: 6,
        paddingRight: 18
      },
      wrapper: {
        cursor: "help",
        zIndex: options.zIndex
      },
      wrapperPosition: {
        left: -1e3,
        position: "absolute",
        top: -1e3,
        visibility: "hidden"
      },
      options: deepmerge2(defaultOptions, options)
    },
    rest
  );
}

// src/index.tsx
import { Fragment as Fragment2, jsx as jsx6, jsxs as jsxs3 } from "react/jsx-runtime";
function ReactFloater(props) {
  const {
    autoOpen = false,
    callback,
    children,
    component,
    content,
    debug = false,
    disableFlip = false,
    disableHoverToClick = false,
    event = "click",
    eventDelay = 0.4,
    footer,
    getPopper,
    hideArrow = false,
    id,
    modifiers,
    offset = 15,
    open,
    placement = "bottom",
    portalElement,
    showCloseButton = false,
    style,
    styles,
    target,
    title,
    wrapperOptions
  } = enhanceProps(props);
  const [state, setState] = useReducer(
    (previousState, nextState) => ({
      ...previousState,
      ...nextState
    }),
    {
      currentPlacement: placement,
      positionWrapper: !!wrapperOptions?.position && !!target,
      status: STATUS.INIT,
      statusWrapper: STATUS.INIT
    }
  );
  const arrowRef = useRef3(null);
  const childRef = useRef3(null);
  const eventDelayTimer = useRef3();
  const floaterRef = useRef3(null);
  const internalId = useRef3(randomId());
  const isMounted = useRef3(false);
  const popperRef = useRef3();
  const stateRef = useRef3(state);
  const wrapperPopper = useRef3();
  const wrapperRef = useRef3(null);
  const wrapperStyles = useRef3({});
  const { currentPlacement, positionWrapper, status, statusWrapper } = state;
  const { changed } = useTreeChanges(state);
  const { changed: changedProps } = useTreeChanges(props);
  const updateState = useCallback2(
    (nextState, callback_) => {
      if (isMounted.current) {
        setState(nextState);
        stateRef.current = { ...state, ...nextState };
        if (callback_) {
          callback_();
        }
      }
    },
    [setState, state]
  );
  const toggle = useCallback2(
    (forceStatus) => {
      let nextStatus = stateRef.current.status === STATUS.OPEN ? STATUS.CLOSING : STATUS.RENDER;
      if (!is5.undefined(forceStatus)) {
        nextStatus = forceStatus;
      }
      updateState({
        status: nextStatus,
        statusWrapper: nextStatus === STATUS.CLOSING ? STATUS.RENDER : STATUS.IDLE
      });
    },
    [updateState]
  );
  const targetElement = useRef3(() => {
    if (!canUseDOM()) {
      return null;
    }
    if (target) {
      if (is5.domElement(target)) {
        return target;
      }
      return document.querySelector(target);
    }
    return childRef.current ?? wrapperRef.current;
  });
  const currentDebug = useMemo2(() => {
    return canUseDOM() && (debug || !!window.ReactFloaterDebug);
  }, [debug]);
  const currentEvent = useMemo2(() => {
    if (event === "hover" && isMobile() && !disableHoverToClick) {
      return "click";
    }
    return event;
  }, [disableHoverToClick, event]);
  const currentStyles = useMemo2(() => {
    const nextStyles = getStyles(styles);
    const element = targetElement.current();
    if (positionWrapper) {
      let wrapperCurrentStyles;
      if (status !== STATUS.IDLE) {
        wrapperCurrentStyles = nextStyles.wrapperPosition;
      } else if (statusWrapper === STATUS.RENDER) {
        wrapperCurrentStyles = wrapperPopper.current?.state.styles;
      }
      nextStyles.wrapper = {
        ...nextStyles.wrapper,
        ...wrapperCurrentStyles
      };
    }
    if (element) {
      const targetStyles = window.getComputedStyle(element);
      if (wrapperStyles.current) {
        nextStyles.wrapper = {
          ...nextStyles.wrapper,
          ...wrapperStyles.current
        };
      } else if (!["relative", "static"].includes(targetStyles.position)) {
        wrapperStyles.current = {};
        if (!positionWrapper) {
          POSITIONING_PROPS.forEach((d) => {
            if (d === "position") {
              wrapperStyles.current[d] = targetStyles[d];
            } else {
              wrapperStyles.current[d] = targetStyles[d];
            }
          });
          nextStyles.wrapper = {
            ...nextStyles.wrapper,
            ...wrapperStyles.current
          };
        }
      }
    }
    return nextStyles;
  }, [positionWrapper, status, statusWrapper, styles]);
  const initPopper = useCallback2(() => {
    const nextStatus = stateRef.current.status === STATUS.RENDER ? STATUS.OPENING : STATUS.IDLE;
    const element = targetElement.current();
    if (placement === "center") {
      setTimeout(() => {
        updateState({ status: nextStatus });
      }, 100);
    } else if (element) {
      if (floaterRef.current) {
        const { arrow, flip, offset: offsetModifier, ...rest } = getModifiers(modifiers);
        popperRef.current = createPopper(element, floaterRef.current, {
          placement,
          strategy: isFixed(targetElement.current()) ? "fixed" : "absolute",
          modifiers: [
            mergeModifier(
              {
                name: "arrow",
                enabled: !hideArrow,
                options: {
                  element: arrowRef.current,
                  padding: 8
                }
              },
              arrow
            ),
            mergeModifier(
              {
                name: "flip",
                enabled: !disableFlip,
                options: {
                  altAxis: false,
                  fallbackPlacements: getFallbackPlacements(placement || "bottom")
                }
              },
              flip
            ),
            mergeModifier(
              {
                name: "offset",
                enabled: true,
                options: {
                  offset: [0, offset]
                }
              },
              offsetModifier
            ),
            {
              name: "updatePlacement",
              enabled: true,
              phase: "afterWrite",
              fn: ({ instance, state: popperState }) => {
                if (popperState.placement !== stateRef.current.currentPlacement) {
                  popperRef.current = instance;
                  updateState({ currentPlacement: popperState.placement });
                }
              }
            },
            {
              name: "applyArrowStyle",
              enabled: true,
              phase: "write",
              fn: ({ state: popperState }) => {
                const {
                  elements: { arrow: stateArrow },
                  placement: statePlacement
                } = popperState;
                if (stateArrow) {
                  if (statePlacement.startsWith("top")) {
                    stateArrow.style.bottom = "0px";
                    stateArrow.style.right = "";
                  } else if (statePlacement.startsWith("bottom")) {
                    stateArrow.style.top = "0px";
                    stateArrow.style.right = "";
                  } else if (statePlacement.startsWith("left")) {
                    stateArrow.style.right = "0px";
                    stateArrow.style.bottom = "";
                  } else if (statePlacement.startsWith("right")) {
                    stateArrow.style.left = "0px";
                    stateArrow.style.bottom = "";
                  }
                }
              }
            },
            ...Object.values(rest)
          ],
          onFirstUpdate: (popperState) => {
            updateState({
              currentPlacement: popperState.placement,
              status: nextStatus
            });
            if (placement !== popperState.placement) {
              setTimeout(() => {
                popperRef.current?.forceUpdate();
              });
            }
          }
        });
        if (getPopper && popperRef.current) {
          getPopper(popperRef.current, "floater");
        }
      } else {
        updateState({
          status: STATUS.IDLE
        });
      }
      if (wrapperRef.current && !wrapperPopper.current && stateRef.current.positionWrapper) {
        const wrapperOffset = wrapperOptions?.offset ? wrapperOptions.offset : 0;
        wrapperPopper.current = createPopper(element, wrapperRef.current, {
          placement: wrapperOptions?.placement ?? placement,
          modifiers: [
            {
              name: "arrow",
              enabled: false
            },
            {
              name: "offset",
              options: {
                offset: [0, wrapperOffset]
              }
            },
            {
              name: "flip",
              enabled: false
            }
          ],
          onFirstUpdate: (popperState) => {
            updateState({ statusWrapper: STATUS.RENDER });
            if (placement !== popperState.placement) {
              setTimeout(() => {
                wrapperPopper.current?.forceUpdate();
              });
            }
          }
        });
        if (getPopper) {
          getPopper(wrapperPopper.current, "wrapper");
        }
      }
    }
  }, [
    disableFlip,
    getPopper,
    hideArrow,
    modifiers,
    offset,
    placement,
    updateState,
    wrapperOptions.offset,
    wrapperOptions?.placement
  ]);
  const handleLoad = useRef3(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
    if (wrapperPopper.current) {
      wrapperPopper.current.forceUpdate();
    }
  });
  const handleTransitionEnd = useRef3(() => {
    if (wrapperPopper.current) {
      wrapperPopper.current.forceUpdate();
    }
    updateState(
      {
        status: stateRef.current.status === STATUS.OPENING ? STATUS.OPEN : STATUS.IDLE
      },
      () => {
        if (callback) {
          callback(stateRef.current.status === STATUS.OPEN ? "open" : "close", enhanceProps(props));
        }
      }
    );
  });
  const handleClick = useCallback2(() => {
    if (is5.boolean(open)) {
      return;
    }
    if (currentEvent === "click" || currentEvent === "hover" && positionWrapper) {
      log({
        title: "click",
        data: [{ event, status: status === STATUS.OPEN ? "closing" : "opening" }],
        debug: currentDebug
      });
      toggle(status === "idle" ? STATUS.RENDER : void 0);
    }
  }, [currentDebug, currentEvent, event, open, positionWrapper, status, toggle]);
  const handleMouseEnter = useCallback2(() => {
    if (is5.boolean(open) || isMobile() || currentEvent !== "hover") {
      return;
    }
    log({
      title: "mouseEnter",
      data: [{ key: "originalEvent", value: event }],
      debug: currentDebug
    });
    if (status === STATUS.IDLE) {
      clearTimeout(eventDelayTimer.current);
      eventDelayTimer.current = void 0;
      toggle(STATUS.RENDER);
    }
  }, [currentDebug, currentEvent, event, open, status, toggle]);
  const handleMouseLeave = useCallback2(() => {
    if (is5.boolean(open) || isMobile()) {
      return;
    }
    if (currentEvent === "hover") {
      log({
        title: "mouseLeave",
        data: [{ key: "originalEvent", value: event }],
        debug: currentDebug
      });
      const hasOpenStatus = [STATUS.OPENING, STATUS.OPEN].includes(status);
      if (!eventDelay) {
        toggle(status === STATUS.CLOSING ? STATUS.IDLE : STATUS.CLOSING);
      } else if (!positionWrapper) {
        if (hasOpenStatus) {
          clearTimeout(eventDelayTimer.current);
          eventDelayTimer.current = window.setTimeout(() => {
            toggle();
            eventDelayTimer.current = void 0;
          }, eventDelay * 1e3);
        }
      }
    }
  }, [currentDebug, currentEvent, event, eventDelay, open, positionWrapper, status, toggle]);
  const handleWrapperMount = useCallback2(() => {
    if (positionWrapper) {
      initPopper();
    }
  }, [initPopper, positionWrapper]);
  const cleanUp = () => {
    if (popperRef.current) {
      popperRef.current.destroy();
      popperRef.current = void 0;
    }
    if (wrapperPopper.current) {
      wrapperPopper.current.destroy();
      wrapperPopper.current = void 0;
    }
  };
  useSingleton(() => {
    if (canUseDOM()) {
      window.addEventListener("load", handleLoad.current);
    }
  });
  useMount(() => {
    isMounted.current = true;
    log({
      title: "init",
      data: {
        hasChildren: !!children,
        hasTarget: !!target,
        isControlled: is5.boolean(open),
        positionWrapper,
        target: targetElement.current(),
        floater: floaterRef.current
      },
      debug: currentDebug
    });
    initPopper();
  });
  useUnmount(() => {
    isMounted.current = false;
    cleanUp();
    window.removeEventListener("load", handleLoad.current);
  });
  useUpdateEffect(() => {
    if (!canUseDOM()) {
      return;
    }
    if (changedProps("open")) {
      let forceStatus;
      if (is5.boolean(open)) {
        forceStatus = open ? STATUS.RENDER : STATUS.CLOSING;
      }
      toggle(forceStatus);
    }
    if (changedProps("wrapperOptions.position") || changedProps("target")) {
      updateState({
        positionWrapper: !!wrapperOptions?.position && !!target
      });
    }
    if (changed("status", STATUS.IDLE) && open || changed("status", STATUS.IDLE, STATUS.INIT) && autoOpen) {
      toggle(STATUS.RENDER);
    }
    if (changed("status", STATUS.RENDER)) {
      if (popperRef.current) {
        popperRef.current.destroy();
      }
      initPopper();
    }
    if (floaterRef.current && changed("status", [STATUS.RENDER, STATUS.CLOSING])) {
      once(floaterRef.current, "transitionend", handleTransitionEnd.current);
    }
    if (changed("status", STATUS.IDLE, STATUS.CLOSING) && popperRef.current) {
      popperRef.current.destroy();
      popperRef.current = void 0;
      if (wrapperPopper.current) {
        wrapperPopper.current.forceUpdate();
      }
    }
  });
  const wrapper = /* @__PURE__ */ jsx6(
    Wrapper_default,
    {
      childRef,
      id: id ?? internalId.current,
      isControlled: is5.boolean(open),
      onClick: handleClick,
      onMount: handleWrapperMount,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      status,
      style,
      styles: currentStyles.wrapper,
      wrapperRef,
      children
    }
  );
  return /* @__PURE__ */ jsxs3(Fragment2, { children: [
    /* @__PURE__ */ jsxs3(
      ReactFloaterPortal,
      {
        hasChildren: !!children,
        internalId: internalId.current,
        placement: currentPlacement,
        portalElement,
        target,
        zIndex: currentStyles.options.zIndex,
        children: [
          /* @__PURE__ */ jsx6(
            Floater_default,
            {
              arrowRef,
              component,
              content,
              floaterRef,
              footer,
              hideArrow: hideArrow || currentPlacement === "center",
              id: id ?? internalId.current,
              onClick: handleClick,
              placement: currentPlacement,
              positionWrapper,
              showCloseButton,
              status,
              styles: currentStyles,
              title
            }
          ),
          positionWrapper && wrapper
        ]
      }
    ),
    !positionWrapper && wrapper
  ] });
}
export {
  ReactFloater as default
};
//# sourceMappingURL=index.mjs.map